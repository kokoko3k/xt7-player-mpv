' Gambas class file

'Copyright (C) 2007, 2008 Antonio Orefice
' Gambas class file

'http://www.mplayerhq.hu/DOCS/tech/slave.txt


'Public Audiofilter As String = "*.mp3;*.ogg;*.aac;*.flac;*.mpc;*.ac3;"
Public wantlog As Boolean = True
Public IsNetworkURI As Boolean = False

Public stdout As String
Public stderr As String
Public modules_out As String

Private Playerprocess As Process
Private RenicerProcess As Process


Private stopping As Boolean = False

Public pausing As Boolean = False
Public return_value As Integer = 0 'playerprocess return value

' Private Takingscreenshot As Boolean = False
'Private lastscreenshot As String = ""
Public last_media As String = ""

Public commandline As String = ""

Private InputPipe As String = ""

Public user_stopped As Boolean = False


Public Function executable(Optional timeout As Integer = -1) As String
  Dim out As String
  Dim proxy As String
  
  out &= out & GeneralOptions.MplayerEnvVars.text & " " 'user specified environment variables
  If GeneralOptions.vdpauooverlaycheck.value = True Then
    out &= " " & "VDPAU_NVIDIA_NO_OVERLAY=1" & " "
  Endif

  out &= "LC_ALL=C "
  proxy = global.proxyfromenv()
  If proxy <> "" Then out &= "http_proxy=" & proxy & " "
  
  If timeout <> -1 Then 
     out &= "timeout -s 9 " & timeout & " "
  Endif

  out &= GeneralOptions.MplayerExeText.Text & " "
  Return out
End


Public CurrentOptions As String = ""

Public AVcodecs As String = ""

Public AudioLanguages As String = "\"\""
Public SubLanguages As String = "\"\""
Public Subfile As String = ""
Public Quick As Boolean = False                         'Skip mediainfo code



Private Sub ClearMediaProperties()

  prop = New Collection
  prop.Clear
  ' setP("time_pos", 0)
  ' setP("Length", 0)
  ' setP("audio-channels", 0)
  ' setP("Height", 0)
  ' setP("width", 0)
  ' setP("trackno", 0)
  ' setP("percent_pos", 0)
  prop["audioonly"] = False
  prop["size"] = 0
  prop["audiotracks"] = New String[] 
  prop["subtitletracks"] = New String[] 
  prop["cddbtracks"] = New String[] 
End


'Realtime Media variables


Public osdlevel As String = ""


Public Function FillMultitracks()
  Dim T, Tcount As Integer
  Dim Type As String
  Dim id, name, lang, tmp, codec As String
  Dim properties As New String[]
  Dim video_ok As Boolean = False

  If getP("fullpath") = "" Then Return
  
  Try prop["audiotracks"].Clear
  Try prop["subtitletracks"].Clear
  Try Tcount = CInt(get_property_mpv("track-list/count"))
  If Error Then
    global.myDebug("WW", "unable to get track count")
    Return
  Endif

  For T = 0 To Tcount - 1
    properties.Clear()
    properties.add("track-list/" & T & "/id")
    properties.add("track-list/" & T & "/title")
    properties.add("track-list/" & T & "/lang")
    properties.add("track-list/" & T & "/type")
    properties.add("track-list/" & T & "/codec")
    get_properties_mpv(properties)
    id = getP("track-list/" & T & "/id") 
    name = getP("track-list/" & T & "/title") 
    lang = getP("track-list/" & T & "/lang") 
    Type = getP("track-list/" & T & "/type") 
    codec = getP("track-list/" & T & "/codec") 
    tmp = (ID & " - " & NAME & " - " & LANG & " - " & CODEC)
    Select Case Type
      Case "audio"
        prop["audiotracks"].Add(Replace(tmp, "(unavailable)", "*"))
      ' Case "video"
        'multiple video tracks unsupported by xt7
      Case "sub"
        prop["subtitletracks"].Add(Replace(tmp, "(unavailable)", "*"))
    End Select
  Next

  video_ok = (get_property_mpv("vo-configured") = "yes")
  video_ok = video_ok And (get_property_mpv("current-vo") <> "(unavailable)")
  setP("audioonly", (Not video_ok))
End

Public Function get_length() As String
  Return get_property_mpv("=duration")
End


Public Sub Renice(nice As Integer, Optional JustThePlayer As Boolean = False)
  global.myDebug("nice=" & nice)
  
  If (Not JustThePlayer) Then RenicerProcess = Shell "renice " & nice & " -p " & Application.id  'renice the whole application to 'nice'
  RenicerProcess = Shell "renice " & (nice - 1) & " -p " & playerprocess.id 
End


Private Function MidC(s As String, a As String, Optional b As String) As String
  'return the first occurrence of the string between a and b
  'if b is omitted then all the string starting from a is returned
  Dim mmid As String
  mMid = Mid(s, InStr(s, a) + Len(a))
  If b <> "" Then 
    Return Left(mmid, InStr(mmid, b) - 1)
      Else
    Return mMid
  Endif
End

Public Sub playerprocess_read(Optional injected As String = "")
  Dim sBuf As String, question, answer As String
  Try Read #playerprocess, sBuf, -4096
  If sBuf Like "ANS_*|*" Then
    For Each sBuf In Split(sbuf, "\n", "", True)
      question = MidC(sBuf, "_", "|")
      answer = (MidC(sBuf, "|"))
      ' If Left(question, 1) = "=" Then 
      '   question = Right(question, -1)
      ' Endif
      Try prop.Remove(question)
      setP(question, answer)
      'Debug question, "=", getP(question)
    Next 'sbuf
      Else
    If sbuf Like "\\[*\\] *" Then
      modules_out &= sBuf & "\n"
        Else
      stdout &= sBuf & "\n"
      
    Endif
  Endif
End

Public Sub playerprocess_error(err As String)
  stderr &= err & "\n"
End



'######################### Player controls section


Public Function SupportsLadspa() As Boolean
  Dim out As String
  Shell executable() & " -af help | grep 'ladspa '" To out
  Return Trim(out) <> ""
End







Public Function dvb_set_channel(channelname As String, dvbcardID As Integer) As Boolean 'fixmempv is stub
  ' Dim channelN As String
  ' 
  ' ChannelN = DvbChannelToNumber(channelname)
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' Wait 0.01
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' Wait 0.01
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' 
  ' CurrentCache = "0"
  ' ClearMediaHeaders()
  ' GotHeaders = False
  ' LastSplittedOutput = ""
  ' Media_FullPath_Playing = ""
  ' Audioonly = False
  ' WaitForHeaders()
  ' GetAllTags()
  ' 
  ' Media_FullPath_Playing = "dvb://" & channelname
  ' Media_FullPath = "dvb://" & channelname
  ' 
  ' 
  ' 
  '     'here we may need to send the last volume (variable=lastvolume) to the running mplayer
  '     'because it seems it resets the volume after each channel change
  '     'the problem is that maybe we need to send it delayed..eg: after the channel as been tuned?
  ' 
  ' Return True
End

Public Function dvb_channel_to_number(C As String) As Integer
  Dim i As Integer
  Dim chans As String[]
  Dim chansfix As New String[]
  Dim chanfile As String = User.home & "/.config/mpv/channels.conf.ter"
  If Not (Exist(chanfile)) Then Return 0
  
  chans = Split(file.Load(chanfile), "\n")
  For i = 0 To chans.Max 'we have to discard any non valid channel line, because so does mplayer
    If Split(chans[i], ":").count = 13 Then chansfix.Add(chans[i])
  Next
  
  For i = 0 To chansfix.Max
    If Trim(chansfix[i]) <> "" Then
      If Lower(Split(chansfix[i], ":")[0]) = Lower(C) Then 
        Return i
      Endif
    Endif
  Next
  Return 0
End


Public mpvoptions As New Collection

Public Sub set_option(name As String, data As String)
 'chr(8) is used instead of null because the collection doesn't keep null values
  While mpvoptions.Exist(name)
    name = " " & name 'prefix white spaces to use multiple options with the same name
  Wend
  mpvOptions[name] = data
  global.myDebug(name, data)
End

Public Sub unset_option(name As String, Optional options As Collection = mpvoptions)
  Dim tName As String = name
  While options.Exist(tName)
    options.Remove(tName)
    tName = " " & tName 'prefix white spaces to use multiple options with the same name
    global.myDebug(tName)
  Wend
End

Private Function set_options() As String
  Dim data, out As String
  For Each data In mpvoptions
    If data <> Chr(8) Then 'chr(8) is used instead of null because the collection doesn't keep null values
      out &= "--" & Trim(mpvoptions.Key) & "=" & data & " " 'trim is needed because we use white spaces to have multiple options with the same name
      global.myDebug("Add option:", mpvoptions.Key, "=", data)
        Else
      out &= "--" & mpvoptions.Key & " "
      global.myDebug("Add option:", mpvoptions.Key)
    Endif
    next_opt:
  Next
  Return out  
End


Private Function fix_options(Optional broken_opts As Collection = mpvoptions) As Collection
  Dim return_opts As Collection = broken_opts.Copy()
  Dim data As String
  'handle corner cases where an option could conflict with another
  For Each data In return_opts
    If data Like "*lavcac3enc*" Then
      If return_opts.Key Like "*af*" Then
        Print "found audio filter lavcac3enc; searching and unsetting --audio-channels"
        Print
        unset_option("audio-channels", return_opts)
        Stop
      Endif
    Endif
  Next
  Return return_opts
End


Public Function get_option(name As String) As String
  Try Return mpvoptions[name]
  If Error Then Return Null
End


Public Sub clear_options()
  mpvoptions = New Collection
End

Public Function waitplayback(timeoutcentisecs As Integer) As Boolean
  Dim cTime As Float = 0

  Repeat
    If Not ProcessRunningOvr() Then Return False
    get_property_mpv("=time-pos", False)
    Wait 0.01
    timeoutcentisecs -= 1
    Try cTime = getP("=time-pos")
  Until (cTime > 0) Or (timeoutcentisecs <= 0)
  If ctime > 0 Then 
    setP("=time-pos", Null)
    Return True
  Endif
  Return False
End

' Public Function waitplayback(timeoutcentisecs As Integer) As Boolean
'   Dim i As Integer
'   Dim cTime As Float = 0
'   For i = 1 To (timeoutcentisecs Div 100)
'     Try cTime = (get_property_mpv("=time-pos", True, "100"))
'     While (ctime = 0) And ProcessRunningOvr()
'       Try cTime = (get_property_mpv("=time-pos", True, "100"))
'       Wait
'     Wend
'     If ctime > 0 Then 
'       setP("=time-pos", Null)
'       Return True
'     Endif
'   Next
'   Return False
' End


Private prop As Collection

Public Sub setP(aKey As String, aData As Variant)
  'set property into a collection in lowercase
  Try prop[Lower(aKey)] = aData
  If Error Then global.myDebug("Error while trying to set: ", aKey, "=", aData)
End

Public Function getP(aKey As String) As Variant
  'get a lowercase property from a 
  If prop.exist(Lower(aKey)) Then Return prop[Lower(aKey)]
  Return Null
End


Public event_loop As Timer





Public watched_properties As New String[]
Public watched_properties_old_data As New String[]

Public Sub event_loop_timer()
  '* generate events on property changes 
  '* keep properties updated
  Dim name, data_new, data_old As String
  Dim i As Integer

  get_properties_mpv(watched_properties, False) 'async ask for those properties
  Wait 0.1
  'see if some property has changed:

  For i = 0 To watched_properties.count - 1
    
    name = watched_properties[i]
    data_new = getP(name)
    data_old = watched_properties_old_data[i]
     
    If data_old <> data_new Then 
      Raise property_change(name, data_old, data_new)
      watched_properties_old_data[i] = data_new
    Endif
  Next

End

Event property_change(name As String, data_old As String, data_new As String)


Private Function internal_options() As Collection
  Dim out As New Collection

  'Returns a collection Of options that will be set every Time, depsite any configuration option

  'out["quiet"] = "yes"
  out["input-file"] = SetUpInputPipe()
  out["msg-color"] = "no"
  out["msg-level"] = "all=v,cplayer=status"
  out["term-status-msg"] = "\"\""
  out["force-seekable"] = "yes" 'this will allow seeks within the cache
  
  'this array will be needed by do_apply().
  'because ut decides if a restart is needed by comparing the changed user options
  'with the previous one. But singe the changed options are set from the outside,
  'which has no clue about those internal_options. we say to do_apply to ignore
  'the following:
  ignore_opts = ["input-file", "msg-color", "msg-level", "term-status-msg", "start", "volume"]

  Return out
End





Public Function do_play(filename As String, Optional string_options As String = "", Optional restart As Boolean = False, Optional bugid1870 As Boolean = False, Optional cookieopts As String = "", Optional dumpfile As String = "/tmp/stream.dump.xt7.mpeg", Optional doanalyze As Boolean = False) As Boolean
  Dim killer_script As String = Temp()
  Dim data As String
  Dim internal_opts As New Collection
  return_value = 0
  If string_options Like "*-idle *" Then 
    Stop
    Return 'fixmempv
  Endif
  
  If ProcessRunningOvr() Then do_stop()
  user_stopped = False 'take this right after the call to do_stop()
  
  internal_opts = internal_options()
  For Each data In internal_opts
    mpvOptions[internal_opts.key] = data
  Next
  
  If global.IsImgFile(filename) Then
    mpvOptions["fps"] = "0.1"
  Endif
  fix_options()
  commandline = executable() & set_options() & string_options
  commandline &= Shell(filename)
  global.myDebug(commandline, commandline)
  last_media = filename
  
  stdout = ""
  stderr = ""
  modules_out = ""
  
  playerprocess = Shell commandline For Read Write As "playerprocess"

  'The following will be a script that will kill mpv if xt7 crashes:
    Copy "killer.sh" To killer_script
    Chmod killer_script To "rwxr-xr-x"

    Shell killer_script & " " & Application.id & " " & playerprocess.id
    global.myDebug(killer_script & " " & Application.id & " " & playerprocess.id)

  watched_properties_old_data.Resize(watched_properties.count)
  event_loop = New Timer As "event_loop"
  event_loop.delay = 500
  event_loop.start
  setP("fullpath", filename)

  Return True
End


Public Struct CDINFO
  Artist As String
  Title As String
  Years As String
  tracks As String[]
End Struct

Private Mycdinfo As Cdinfo
Public Sub get_cdda_info(device As String, Optional cddb As Boolean = True) 
  Dim dcl, t, l, start_time, pstart_time As String
  Dim track As Integer = 0
  Dim length As String = 0
  Dim Mycd As New Cddb
  Dim tName As String

  If cddb Then 
    mycd = New CDDB
    Mycdinfo = mycd.cddb_query(device, 100) 
  Endif

  dcl = get_property_mpv("=chapter_list", True, 1000)
  global.myDebug(dcl)
  
  dcl = Replace(dcl, "[", "")
  dcl = Replace(dcl, "]", "")
  dcl = Replace(dcl, "},{", Chr(8))
  dcl = Replace(dcl, "{", "")
  dcl = Replace(dcl, "}", "")  

  start_time = 0
  track = 1
  
  For Each t In Split(dcl, Chr(8), "", True)
    pstart_time = start_time
    start_time = (Split((Split(t, ",")[1]), ":")[1])
    l = CFloat(start_time) - CFloat(pstart_time)
    'Length = mplayer.FormatTime(Split(l, ".,")[0])
    length = Split(l, ".,")[0]
    tName = ""

    If cddb Then Try tName = Trim(Mycdinfo.tracks[track - 1])
    prop["cddbtracks"].add(tname & Chr(8) & length)
    track += 1
  Next 'track
End

Public Function cdda_device(fullpath As String) As String
  'dvd://24//path/to/dvd/device -> /path/to/dvd/device
  'dvd://dev/sr0  -> /dev/sr0
  'dvd://1 -> "/"
  'dvd:// -> "/"
  'dvd://menu//path/to/something -> "/path/to/something"
  Dim t As String
  Dim ret As String
  Try t = Split(fullpath, "/", "", True)[1] ' dvd://24//path/to/dvd/device -> 24
                                            ' dvd:// -> ""
                                            ' dvd:///path/to/dvd/device -> path
  If IsInteger(t) Then 
     ret = Replace(fullpath, "cdda://" & t, "")
       Else
     ret = Replace(fullpath, "cdda://", "")
   Endif
   If Left(ret, 1) <> "/" Then ret = "/" & ret
   Return ret
End

Public Function get_mediainfo(Optional cddb As Boolean = True) As Boolean 
  Dim media_taglib As New TagLib
  Dim fileUtf8 As String
  Dim properties As String[]
  
  If getP("fullpath") = "" Then Return

' ' ''ENUM Artist, title etc via mpv Metadata
' '     metadatacount = GetPropertympv("metadata/list/count")
' '     If metadatacount > 0 Then
' '       For i = 0 To metadatacount - 1
' '         metadataname = GetPropertympv("metadata/list/" & i & "/key")
' '         global.myDebug( metadataname, GetPropertympv("metadata/by-key/" & metadataname))
' '       Next
' '     Endif
' '   ''

  If Not waitplayback(3000) Then
    global.myDebug("EE", "Playback didn't started or timeout waiting for it to start")
    do_stop()
    Return False
  Endif
  

  'fixmempv: questa procedura sotto, cosa fa esattamente? mi sembra solo il trim (?)
    Try fileUtf8 = DConv(getP("fullpath")) 'from system charset to utf8
    If Error Then fileutf8 = getP("fullpath")
    fileutf8 = getP("fullpath")
    fileutf8 = Trim(fileutf8)

  FillMultitracks() 'will set prop[audioonly] too.

  Try setP("size", (Stat(getP("fullpath"), True).Size Div 1024))
  
  properties = New String[]
  properties.insert(["filename", "partially-seekable", "file-format", "audio-codec"]) 'common
  'properties.Insert(["=audio-bitrate", "audio-channels", "=audio-channels", "=audio-samplerate"]) 'common
  properties.Insert(["=audio-bitrate", "audio-params/channels", "=audio-params/channels", "=audio-params/samplerate"]) 'common
  If Not getP("audioonly") Then
    properties.Insert(["video-codec", "video-params/dw", "video-params/dh"]) 'video files
  Endif

  
  
  'for audio only files, try to get common audio tags
  'try first to get them using fast taglib
  'fixmempv --> but fallback to mplayer in idle mode <--fixmempv

  If (getP("AudioOnly") And (Not Global.IsNetworkURI(getP("FullPath")))) Then
    If media_taglib.IsSupported(fileutf8) And media_taglib.Init(getP("FullPath")) Then
      setP("artist", media_taglib.Artist)
      setP("author", media_taglib.Artist)
      setP("title", media_taglib.Title)
      setP("album", media_taglib.Album)
      setP("genre", media_taglib.Genre)
      setP("year", media_taglib.MyYear)
      setP("comment", media_taglib.Comment)
      setP("comments", media_taglib.Comment)
      setP("trackno", media_taglib.Track)
      setP("=duration", media_taglib.Length)
      setP("duration", FormatTime(media_taglib.Length))
      If getP("=duration") = 0 Then properties.add("=duration")
      If getP("duration") = 0 Then properties.add("duration")
      setP("=Audio-Bitrate", media_taglib.Bitrate)
      If getP("=Audio-Bitrate") = 0 Then properties.add("=audio-bitrate")
      setP("=audio-params/channels", media_taglib.Channels)
      If getP("=audio-params/channels") = 0 Then properties.add("=audio-params/channels")
      setP("=audio-params/samplerate", media_taglib.Samplerate)
      If getP("=audio-params/samplerate") = 0 Then properties.add("=audio-params/samplerate")
      global.myDebug("got info from taglib on " & getP("FullPath") & " --")
      
       media_taglib.tlFree()
        Else  'there was a problem with TagLib Class initialization, fallback to mplayer
              'or was a network uri or a cddb 
      If global.IsCdaudio(getP("FullPath")) Then 'fixmempv cddb allow to choose if user wants cddb
        get_cdda_info(cdda_device(getP("FullPath")), cddb)
        If cddb Then
          Try setP("Artist", Mycdinfo.Artist)
          Try setP("author", Mycdinfo.Artist)
          Try setP("year", Mycdinfo.years)
          Try setP("year", Mycdinfo.years)
          Try setP("album", Mycdinfo.title)
        Endif
      Endif

      If Not (global.IsCdaudio(getP("FullPath")))
        Try setP("Artist", get_property_mpv("metadata/by-key/ARTIST"))
        Try setP("Author", get_property_mpv("metadata/by-key/AUTHOR"))
        Try setP("Genre", get_property_mpv("metadata/by-key/GENRE"))
        Try setP("Album", get_property_mpv("metadata/by-key/ALBUM"))
        Try setP("Year", get_property_mpv("metadata/by-key/DATE"))
        ' Try Media_CreationDate = DConv(FindAudioTag("creation date")) 'fixmempv
        Try setP("TrackNo", get_property_mpv("metadata/by-key/track"))
        Try setP("Title", get_property_mpv("metadata/by-key/TITLE"))
        If getP("Title") = "" Then Try setP("name", get_property_mpv("metadata/by-key/TITLE"))
        ' Try Media_Comment = DConv(FindAudioTag("comment")) ' & Media_ExtraComment 'fixmempv mpv doesnt support comments...
        ' Try Media_Comments = DConv(FindAudioTag("comments")) ' & Media_ExtraComment 'fixmempv mpv doesnt support comments...
      Endif
      
      If (getP("=duration") = 0) Or (getP("=duration") = "") Then properties.insert(["=duration", "duration"])

    Endif
        Else 'for not audio only files, use mpv
      properties.insert(["=duration", "duration"])
      If (Not getP("audioonly")) Then
        properties.Insert(["=video-bitrate", "width", "height", "fps"])            
      Endif

  Endif

  get_properties_mpv(properties)
  
  If getP("duration") = "" Then setP("duration", "00:00:00")
  If getP("=duration") = "" Then setP("duration", "0")
  Return True
End


Public maxcache As String = "0"

Private Function parsecacheparam(commandline As String) As String
Dim start As Integer
Dim tmp As String
  If commandline Like "* -cache *" Then
    start = InStr(commandline, "-cache")
    tmp = Mid(commandline, start, Len(commandline))
    tmp = Trim(tmp)
    tmp = Split(tmp, " ", "", True, False)[1]
    tmp = Trim(tmp)
    Return tmp
      Else
    Return "0"
  Endif
End





Private Function TemporaryPlaylist(Fullpath As String) As String
  'This is an hack because mplayer in idle mode doesn't like some filenames (i can't understand why)

  Dim tmpfile As File
  Dim PlaylistFileName As String = Temp("mytmpfile")

  tmpfile = Open PlaylistFileName For Write Create
  Print #tmpfile, Fullpath
  Close tmpfile
  Return PlaylistFileName

End




Public Function do_IdlePlay(filename As String) As Boolean
  'warning: call this function is mutually exclusive to calling do_play()
  'eg: if you started mpv with do_play(), you need another instance Of this class.
  'check if the process is alive || start it
  If Not ProcessRunningOvr() Then
    mpvoptions.Clear
    set_option("input-file", SetUpInputPipe())
    set_option("msg-color", "no")
    set_option("term-status-msg", "")    
    set_option("ao", "null")   
    set_option("vo", "null")   
    set_option("idle", "yes")
    set_option("cache", "no")
    commandline = executable(600) & set_options()
    playerprocess = Shell commandline For Read Write As "playerprocess"
  Endif

  mpv_command(["loadfile", SConv(FileName)])
  setP("fullpath", filename)
  do_leave_pause()
  If Not quick Then get_mediainfo(False)
  mpv_command(["stop"])
End




Public Function DoDeinterlace()
  If commandline Like "*vdpau*" Then
    send("step_property deinterlace")
    Return
  Endif
  If commandline Like "*yadif*" Then
    send("step_property deinterlace")
    Return
  Endif
  If commandline Like "*xvmc*" Then
    send("step_property deinterlace")
    Return
  Endif
  If commandline Like "*vaapi*" Then
    send("step_property deinterlace")
    Return
  Endif
  If commandline Like "*kerndeint*" Then
    send("step_property deinterlace")
    Return
  Endif
  ShowText("Can't deinterlace, missing vdpau,xvmc,vaapi,yadif or kerndeint", 3000)
End


Public AudioSwitched As Boolean = False


Private SUPPORTEDAUDIOFILTERS As New String[] 
Public Sub afclr() 'fixmempv
  'get the current audio filters and remove them one by one.
  'needed because -af_clr slave command doesn't seem to work.
  Dim out, filter As String
  If SUPPORTEDAUDIOFILTERS.count = 0 Then 
    Shell executable() & " -af help |grep ' : '" To out 
    For Each filter In Split(out, "\n", "", True)
      SUPPORTEDAUDIOFILTERS.add(Split(Trim(filter), " ", "", True)[0])
    Next 'filter
  Endif
  For Each filter In SUPPORTEDAUDIOFILTERS
    send("af_del " & filter) 'do it four times to be sure multiple instances
    send("af_del " & filter) 'of the same filter are removed as well
    send("af_del " & filter)
    send("af_del " & filter)
  Next 'filter
End



Public Function ProcessRunningOvr() As Boolean
  'As gambas returns runtime error if process is not ready,
  'we'll catch it here
  Dim running As Boolean = False
  Try running = (playerprocess.state = 1)
  Return running
End

Public Function do_stop() As Boolean
  Dim maxtimeout As Integer = 100
  Dim timeout As Integer 
  Try event_loop.Stop
  Try mpAnalyze.kill
  AudioSwitched = False
  stopping = True

  If Not restarting Then 
    If ProcessRunningOvr() Then user_stopped = True
    ClearMediaProperties()
    properties_changed_runtime.clear
    StopOverBrightAnalyze()
  Endif
  timeout = maxtimeout
  Repeat 'be kind
    send("quit")
    Wait 0.01
    timeout = timeout - 1
  Until ((timeout <= 0) Or (Not ProcessRunningOvr()))
  timeout = maxtimeout
  Repeat 'ne rude !
    Try Playerprocess.Kill
    Wait 0.01
    timeout = timeout - 1
    Until ((timeout <= 0) Or (Not ProcessRunningOvr()))

  Try Close #mystream
  Try Kill inputpipe
  Return True
End


Public Function do_ffwd() As Boolean
  If Not ProcessRunningOvr() Then Return
  mpv_command(["multiply", "speed", "1.059463094352953"])
End

Public Function do_slow() As Boolean
  If Not ProcessRunningOvr() Then Return
  mpv_command(["multiply", "speed", "0.9438743126816935"])
End


Public Function do_SetVolume(Percentual As String, Optional osd As Boolean = False) As Boolean
  If Not ProcessRunningOvr() Then Return
  set_property_mpv("volume", Percentual, osd)
End


Public Function do_volume_add(Percentual As String, Optional osd As Boolean = False) As Boolean
  If Not ProcessRunningOvr() Then Return
  set_property_mpv("volume", Percentual, osd)
End

'######################### Media Properties Section






Public Function CurrentTime() As String
  Dim reply As String
  If Not ProcessRunningOvr() Then Return "0" 
  reply = get_property_mpv("=time-pos")
  Try Return Split(reply, ".")[0]
  If Error Then Return "0"
End

Public Sub CurrentTimeFloat() As String
  Dim out As String
  If Not ProcessRunningOvr() Then Return "0"
  out = get_property_mpv("=time-pos")
    If out = "" Then 
      Return "0"
    Else
      Return out
  Endif
End


Public Sub ShowText(message As String, Optional myTime As Integer = 2000)
  mpv_command(["show_text", message, mytime])
End

Public Function IsSubFile(SubfilePath As String) As Boolean

  Dim SubExtensions As String = "*.SRT;*.ASS;*.SUB;*.SSA;"
  Dim fileExt As String = "." & File.Ext(SubfilePath)

  If Fileext = "." Then Return False
  If (InStr(Upper(SubExtensions), Upper(fileExt)) > 0) Then
    Return True
  Else
    Return False
  Endif

End


Public Sub sub_add(file As String, UseSub As Boolean)
  If Usesub Then 
    mpv_command(["sub_add", file, "select"])
      Else
    mpv_command(["sub_add", file])
  Endif
End


Public Function get_screenshot(DeleteFILE As Boolean) As Picture

  Dim Screenshot As Picture
  Dim timeout As Integer = 20
  Dim picfile As String = Temp() & ".jpg"
 
  If Not ProcessRunningOvr() Then Return
  Try Kill picfile

  mpv_command(["no-osd", "screenshot_to_file", picfile, "video"])

  While Not Exist(picfile) 'wait for mplayer answer
    Wait 0.05
    timeout = timeout - 1
  Wend
  If timeout <= 0 Then Goto errorlabel
  timeout = 20
  Repeat 'try to load the picture and eventually wait for it to be written on the disk
    Try Screenshot = picture.Load(picfile)
    If screenshot = Null Then
      Wait 0.05
      timeout = timeout - 1
    Endif
  Until (screenshot <> Null) Or timeout <= 0
  If timeout <= 0 Then Goto errorlabel

  If Deletefile Then Try Kill picfile
  Return Screenshot

  errorlabel:
    If Deletefile Then Try Kill picfile
    global.myDebug("Timeout Error: Screenshot file does not exists!")
    Return picture["null.png"]
End


Public Sub FormatTime(seconds As String) As String

  Dim iseconds, hh, mm, ss, restosec As Integer
  Dim Shh, Smm, Sss As String
  If seconds = "" Then Return "00:00:00"
  seconds = Split(seconds, ".", "", True)[0]
  Try iseconds = Val(seconds)
  If Error Then iseconds = 0
  hh = iseconds Div 3600
  restosec = (iseconds - (hh * 3600))
  mm = restosec Div 60
  ss = (restosec - (mm * 60))
  Sss = ss
  If Len(Sss) = 1 Then Sss = "0" & Sss
  Smm = mm
  If Len(Smm) = 1 Then Smm = "0" & Smm
  Shh = hh
  If Len(Shh) = 1 Then Shh = "0" & Shh
  Return Shh & ":" & Smm & ":" & Sss

End

Public Function DeFormatTime(FormattedTime As String) As String

  Dim ss, mm, hh As Integer

  Try ss = Split(FormattedTime, ":")[2]
  If Error Then ss = "0"
  Try mm = Split(FormattedTime, ":")[1]
  If Error Then mm = "0"
  Try hh = Split(FormattedTime, ":")[0]
  If Error Then hh = "0"
  Return ss + (mm * 60) + (hh * 3600)


End



Public Sub Media_get_length() As String

  ' Dim t1 As String = ""
  ' Dim ofpos, i As Integer = 0
  ' 
  ' 
  ' 'Next, let's see if it is an audio only or an audio/video file,
  ' 'we need to know because of buggy ID_LENGTH behaviour:
  ' 
  ' If Media_AudioOnly() Then
  '   i = MediaHeaders.Count - 1        'we'll reverse the search here to speedup, probably
  '   Repeat
  '     t1 = Trim(MediaHeaders[i])
  '     If (t1 Like "*)*") And (t1 Like "* of *") And (t1 Like "*%*") And (t1 Like "*:*") And Not (InStr(t1, Media_FullPath)) Then
  '       ofpos = InStr(t1, " of ")
  '       'clear all the chars before " of " (included):
  '       Media_Length = Mid(t1, ofpos + 4, 10)
  '       'find first space
  '       ofpos = InStr(t1, " ")
  '       'copy the string until that
  '       Media_Length = Mid(Media_Length, 1, ofpos)
  '       Return Media_Length
  '     Endif
  '     i = i - 1
  '   Until (i = 0) Or (Media_Length <> "0")
  '   
  ' Else 'is a video/audio file
  '   i = 0
  '   Repeat
  '     Try t1 = Trim(MediaHeaders[i]) 'fixme
  '     If (t1 Like "*ID_LENGTH*") Then
  '       Media_Length = GetTagValue(t1, "ID_LENGTH")
  '     Endif
  '     i = i + 1
  ' 
  '   Until (i >= MediaHeaders.Count) Or (Media_Length <> "0")
  ' Endif
  ' Return Media_Length

End

Public Function DeMuxerslist() As String[]
  'returns a string array of supported audio codecs plus informations

  Dim MPoutput As String
  Dim MPLines, FuncOUT As New String[]
  Dim MPLine, MPWord As String
  Dim HeadSkipped As Boolean = False
  Dim CheckHead As String = "demuxer:"
  Dim Option As String = " --config=no -demuxer help"
  Dim spaces_before As String = ""

  CheckHead = "demuxer:"
  
  Shell executable() & " " & Option To MPoutput
  MpLines = Split(MPOutput, "\n", "", True)
  For Each MPLine In MPLines
    MPWord = Trim(Split(MPLine, " ", "", True)[0])
    If MPWord = CheckHead Then HeadSkipped = True
    ' 'get just the first word
    If HeadSkipped And mpword <> CheckHead Then
      spaces_before = "  "
      'Move white spaces From nefore the word To the End Of the word
      While Left(mpline) = " " 
        mpline = Right(mpline, -1)
        spaces_before &= " "
      Wend
      MPWord = MPWord & spaces_before & Right(mpline, - Len(mpword))
      FuncOUT.Add((MPWord))
    Endif
  Next
  Return FuncOut

End


Public Function CodecsList(TYPE As String) As String[]
  'returns a string array of supported audio codecs
  'returns a string array of supported audio codecs plus informations
  Dim MPoutput As String
  Dim MPLines, FuncOUT As New String[]
  Dim MPLine As String
  Dim HeadSkipped As Boolean = False
  Dim CheckHead As String = "demuxer:"
  Dim Option As String = " --config=no -demuxer help"
  Dim cname, cdesc As String

  If TYPE = "AUDIO" Then
    CheckHead = "Audio decoders:"
    Option = " --config=no  -ad help"
  Else
    CheckHead = "Video decoders:"
    Option = " --config=no  -vd help"
  Endif
  Shell executable() & " " & Option To MPoutput
  MpLines = Split(MPOutput, "\n", "", True)
  For Each MPLine In MPLines
    cname = ""
    cdesc = ""
    mpline = Trim(mpline)
    If mpline = CheckHead Then HeadSkipped = True
    ' 'get just the first word
    If HeadSkipped And mpline <> CheckHead Then
      cname = Trim(Split(mpline, "-", "", True)[0])
      cdesc = Trim(Split(mpline, "-", "", True)[1])
      Repeat 
        cname &= " "
      Until Len(cname) >= 40
      FuncOUT.Add((cname & cdesc))
    Endif
  Next

  Return FuncOut

End


Public Function GetListOf(TheType As String) As String[]
  'return a list of available drivers/filters
  'thetype can be ao,vo,af,vf
  Dim list, mpline As String
  Dim outlist As New String[]
  Shell executable() & "  --config=no -" & TheType & " help" To List
  global.myDebug(Timer)
  For Each mpline In Split(list, "\n", "", True)
    outlist.Add(Lower(Split(mpline, " \t", "", True)[0]))
  Next 'mpline
  Return outlist
End




Public thumbprocess As Process
Private newfilenamepriv As String
Private outdirpriv As String
Private Thumbfullpathpriv As String
Private widthpriv As Integer
Private columnpriv As Integer
Private rowpriv As Integer
Private gridpriv As Gridview



Public Sub savethumb(fullpath As String, newfilename As String, Optional width As Integer = 256, Optional seconds As Integer = 300, mygrid As Gridview, row As Integer, column As Integer) 
  Dim outdir As String = Shell(Temp()) & Rnd(0, 99999)
  Dim cmdline As String = ""

  Mkdir outdir

  rowpriv = row
  columnpriv = column
  gridpriv = mygrid

  'Create the thumb, but exit after 30 seconds 
  cmdline = executable(5) & " " & Shell(fullpath) & " --cache=no "
  cmdline &= "-vf scale=" & width & ":-2" & ",expand=::::1/1" & " --no-sub" & " --start " & seconds 
  cmdline &= " -frames 1 --no-audio --vo=image:format=jpg:jpeg-quality=80:outdir=" & outdir
  cmdline &= " --config=no -quiet &>/dev/null"

  newfilenamepriv = newfilename
  outdirpriv = outdir
  Thumbfullpathpriv = fullpath
  widthpriv = width
  global.myDebug(cmdline)
  global.myDebug("")
  thumbprocess = Shell cmdline For Input As "thumbprocess" 
End

Private restarting As Boolean = False
Public Sub playerprocess_kill()
  return_value = playerprocess.value
  If (Not restarting) Then 
    ClearMediaProperties()
    Raise mykill(return_value)
  Endif
End

Event mykill(return_value As Integer)
Event ThumbAvailableFor(fullpath As String, g As Gridview, r As Integer, c As Integer)
Event ThumbErrorFor(fullpath As String, g As Gridview, r As Integer, c As Integer)


Private ShortMovieChecked As Boolean = False
Public Sub thumbprocess_kill()
  Try Copy outdirpriv & "/" & Dir(outdirpriv, "*")[0] To newfilenamepriv
  Shell "rm -R " & outdirpriv & "&>/dev/null"
  If Exist(newfilenamepriv) Then
    Raise ThumbAvailableFor(Thumbfullpathpriv, gridpriv, rowpriv, columnpriv)
      Else
    If ShortMovieChecked Then 
      Raise ThumbErrorFor(Thumbfullpathpriv, gridpriv, rowpriv, columnpriv)
        Else 'maybe the movie was very short, try to get a screen at 5th second:
      global.myDebug("Couldn't get a thumb, retrying with an earlier time")
      ShortMovieChecked = True
      savethumb(Thumbfullpathpriv, newfilenamepriv, widthpriv, 150, gridpriv, rowpriv, columnpriv)
    Endif
  Endif
End



Public Sub ExtractAudioTo(src As String, dest As String)
  do_play(src, " -vo null -vc null -ao pcm:waveheader:fast:file=" & dest, False, False)
End


Public Sub StartOverbrightAnalyze()
  If Not ProcessRunningOvr() Then Return
  stopob = False
  TimerAnalyzePRE = New Timer As "TimerAnalizePRE"
  TimerAnalyzePRE.Delay = 10
  TimerAnalyzePRE.start
End

Private StopOB As Boolean = False
Public Sub StopOverBrightAnalyze()
  Try mpanalyze.kill
  Try TimerAnalyzePRE.stop
  Try TimerAnalyze.stop
  Try mpanalyze.kill
  StopOB = True
End




Private barray As String[]
Public mpAnalyze As Process
Private PrevCtime As Integer = -1

Public Sub Analyze(videofile As String)
  Dim cmd As String
  Dim newpos As Integer
  Dim i As New Image
  Dim bAvg As Integer
  Dim tmpdir As String = Temp() & "/"
  Dim pLine, t As String
  Dim mystream As File
  Dim cTime, cTimei, cTimef As String
  Dim outfile As String[]
  Dim sFile As String
  Dim timeout As Integer
  lStart:
  While ProcessRunningOvr()
    If stopob Then Goto lEnd
    barray = New String[80000] 
    barray.Fill(-1, 0, 80000)
    Shell "rm -Rf " & tmpdir Wait
    Shell "mkdir -p " & tmpdir Wait
    Shell "rm " & tmpdir & "/fifo" Wait
    Shell "mkfifo " & tmpdir & "/fifo" Wait
    Try mystream.close
    mystream = Open tmpdir & "/fifo" For Write
    Print #mystream, "no-osd set pause yes"
    'cmd = "mplayer  -noconfig all -noautosub -nosub -osdlevel 0  -lavdopts fast:skiploopfilter=all -speed 0.01 -slave -input file=" & tmpdir & "/fifo  -vf scale=64:64:0:3,scale=16:16:0:3,smartblur=5:1:0,scale -nosound -vo jpeg:quality=100:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    cmd = executable() & " --term-status-msg='${=time-pos}' --config=no --no-sub --osd-level=0 --vd-lavc-skiploopfilter=all --speed 0.01 --input-file=" & tmpdir & "/fifo --vf=scale=16:16  --no-audio --vo=image:format=png:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    'cmd = "mplayer  -noconfig all -noautosub -nosub -osdlevel 3  -lavdopts fast:skiploopfilter=all -speed 0.01 -slave -input file=" & tmpdir & "/fifo  -nosound -vo jpeg:quality=100:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    global.myDebug(cmd)
    mpanalyze = Shell cmd
    Repeat
      If stopob Then Goto lEnd
      Sleep 0.05
      Try t = File.Load(tmpdir & "/mpout")
    Until (Not Error )
    Repeat
      Try outfile = Split(File.Load(tmpdir & "/mpout"), "\n")
      Sleep 0.05
    Until (outfile.max > 1)

    While mpanalyze.state = Process.Running
      'Debug
      If stopob Then Goto lEnd
      For Each sFile In Dir(tmpdir, "*.png*")
        Kill tmpdir & "/" & sFile
      Next
      
      'step ahead
       newpos = CInt(currenttime()) + 4
      If Not Error Then 
        'Print #mystream, "pausing_keep seek " & CStr(newpos) & " 2"
        Print #mystream, "no-osd seek " & CStr(newpos) & " absolute keyframes"
        'Debug "Analize newseek", newpos
      Endif
      Repeat
        'If paused Or pausing Then TimerAnalyze.stop
        If paused() Then TimerAnalyze.stop
        Wait 1
        If stopob Then Goto lEnd
      Until Not paused()
      'Until Not (paused Or pausing)
      TimerAnalyze.start
      'Print #mystream, "pausing_keep seek +1"
      
      'wait for pic
      timeout = 100
      If Not Exist(tmpdir) Then Goto lStart
      While Dir(tmpdir, "*.png").count = 0 And (timeout > 0) And mpanalyze.state = Process.Running
        Wait 0.01
        timeout -= 1
      Wend
      If timeout = 0 Then 
        global.myDebug("No Pics, restarting analyzer")
        Try mpanalyze.Kill
        Goto lStart
      Endif
      
      '''''''''If (timeout <= 0) Or (mpanalyze.state <> Process.Running) Then Goto lEnd
      outfile = Split(File.Load(tmpdir & "/mpout"), "\n\r", "", True) '<- this is sloooow over time, watchout!

      
      pLine = outfile[outfile.max - 1]
      'Try cTime = Val(Trim(Mid(pLine, 3, InStr(pLine, ".") - 3)))
      'Try ctime = CFloat(Trim(Mid(pLine, 3, InStr(pLine, ".") - 1))) 'get the current float time
      Try ctime = CFloat(Trim(pLine)) 'get the current float time
      
      Try cTimei = Split(cTime, ".")[0]
      Try cTimef = Split(cTime, ".")[1]
      Try t = tmpdir & Dir(tmpdir, "*.png")[0]
      If Exist(t) Then
        Try i = i.Load(tmpdir & Dir(tmpdir, "*.png")[0])
        'Shell "mv  " & (tmpdir & Dir(tmpdir, "*.jpg")[0]) & " /tmp/tmp/" & ctime & ".jpg" Wait
        If Not Error Then 
          bavg = c_mean(i)
          'bavg = Color[i.Pixels[0]].value 
          'global.myDebug("time", ctime, "AVG:", bavg)
          'barray index represents the integer part of the time, so we store the float part with the average picture brightness value in the array cell
          'and set a delay afterwards for near pefect timing
          Try barray[cTimei] = bAvg & ":" & ctimef
          
        Endif
      Endif
    Wend
  Wend
  lEnd:
  stopob = False
  mpanalyze.kill
  Shell "rm -Rf " & tmpdir
End

Private Function c_mean(img As Image) As Integer
Dim i, s As Integer
Dim skiprows As Integer = img.Pixels.count Div 8
'an imprecise color mean
  For i = skiprows To img.Pixels.Count - skiprows Step 3
    s += Color[img.Pixels[i]].value
  Next
  Return CInt(s / (img.Pixels.count - (skiprows * 2))) * 3
End

Public TimerAnalyzePre As Timer
Public Sub TimerAnalizePRE_timer()
  TimerAnalyzePRE.stop
  TimerAnalyze = New Timer As "TimerAnalize"
  TimerAnalyze.delay = 33 'should be ok till 30fps source material
  TimerAnalyze.start
  Analyze(Shell(SConv(getP("FullPath"))))
End

Public TimerAnalyze As Timer

Event AnalyzerNewValue(bAvg As Integer, delay As Float)

Public Sub TimerAnalize_timer()
  Dim cTime As Integer
  Dim bAvg As String
  Dim delay As Float
  Try cTime = CInt(CurrentTime())
  If Error Then Return
  If PrevCtime = cTime Then Return
  prevCtime = cTime
  If ctime < 0 Then Return
  bAvg = Split(barray[ctime], ":")[0]
  If bAvg <> -1 Then
    TimerAnalyze.Stop
    'Debug "New value at index", i, bout[3]
    'ShowText("Tempo media: " & ctime & " media: " & bAvg & " Tempo filmato " & CurrentTimeFloat())
    'ShowText("barray: " & ctime & "movie: " & CurrentTimeFloat(), 1000)
    delay = CFloat("0." & Split(barray[ctime], ":")[1])
    delay = delay - (CFloat(CurrentTimeFloat()) - cTime)

    Try Raise AnalyzerNewValue(bAvg, delay, cTime)
    global.myDebug("NewValue")
    If Not stopob Then TimerAnalyze.start
      'Else
    'Debug "missing value in barray"
  Endif
End


Private mystream As Stream
Private Function SetUpInputPipe() As String
  Dim Random1 As Integer = 0
  Randomize
  Random1 = Int(Rnd(0, 65535))
  Try Mkdir global.confpath & "/.InputPipes"
  inputpipe = global.confpath & "/.InputPipes/Xt7Input-" & Random1
  If Exist(inputpipe, True) Then 
    Shell "rm '" & inputpipe & "' &>/dev/null" Wait
  Endif
  mystream = Pipe inputpipe For Write
  global.myDebug("inputpipe=", inputpipe)

  Return inputpipe
End


Public Function do_pause() As Boolean
  set_property_mpv("pause", "yes")
  Return get_property_mpv("pause", True) = "yes"
  'fixmempv cicla finchè non in pausa
End


Public Function do_leave_pause() As Boolean
  set_property_mpv("pause", "no")
  Return get_property_mpv("pause", True) = "no"
End


Private properties_changed_runtime As New Collection 'holds changed properties to be set again after a restart

Public Function set_property_mpv(name As String, data As String, Optional osd As Boolean = False) 
  'mpv_command(["set_property_string", name, data])
  Dim s As String = "\\"
  Dim q As String = "\""

  data = Replace(data, q, s & q)        'replace " with \"
  data = Replace(data, s & s & q, s & q) 'replace \\" with \" (in case we quoted an already quoted string)
  If osd Then 
    mpv_command(["osd-msg", "set", name, data])
      Else
    mpv_command(["no-osd", "set", name, data])
  Endif
  properties_changed_runtime[name] = data

End

Public Function add_property_mpv(name As String, data As String, Optional osd As Boolean = False) 
  'mpv_command(["set_property_string", name, data])
  Dim s As String = "\\"
  Dim q As String = "\""

  data = Replace(data, q, s & q)        'replace " with \"
  data = Replace(data, s & s & q, s & q) 'replace \\" with \" (in case we quoted an already quoted string)
  If osd Then 
    mpv_command(["osd-msg", "add", name, data])
      Else
    mpv_command(["no-osd", "add", name, data])
  Endif
  properties_changed_runtime[name] = data

End


Private available_options As New String[]

Public Sub list_options() As String[]
  Dim o, opts As String
  If available_options.count > 0 Then Return available_options
  Shell executable() & " --list-options|grep '\\-\\-'|cut -d '-' -f 3-|cut -d ' ' -f 1" To opts
  For Each o In Split(opts, "\n", "", True)
    available_options.Add(o)
  Next
  Return available_options
End



Public Function get_property_mpv(name As String, Optional wait_answer As Boolean = True, Optional timeoutcentisecs As Integer = 100, try_cached As Boolean = False) As String
  Dim dataout As String
  Dim cachedP As Variant
  If try_cached Then
    Try cachedP = getP(name)
     If cachedP <> Null Then Return cachedP
  Endif

  dataout = "print_text "
  dataout &= "ANS_" & name & "|"
  dataout &= "${"
  dataout &= name
  dataout &= ":(unavailable)}"
  'clear previous answer
   If wait_answer Then setP(name, Null)
  'say mpv to answer 
  send(dataout)
  'Debug "asking ", dataout
  If wait_answer Then
    While (timeoutcentisecs >= 0) And ProcessRunningOvr()
      If getP(name) <> Null Then Return getP(name)
      timeoutcentisecs -= 1
      send(dataout)
      ' global.myDebug( "asking ", dataout)
      Wait 0.01
    Wend
    'global.myDebug( name & " --> " & getP(name))
    Return getP(name)
  Endif
End

Public Function get_properties_mpv(names As String[], Optional wait_answer As Boolean = True, Optional wait_unavailable As Boolean = False, Optional timeoutcs As Integer = 500)
  Dim name, dataout, p As String
  Dim got As Boolean
  For Each name In names
    dataout = "print_text "
    dataout &= "ANS_" & name & "|"
    dataout &= "${"
    dataout &= name
    dataout &= ":(unavailable)}"
    'clear previous answer
    If wait_answer Then setP(name, Null)
    'say mpv to answer 
    send(dataout)
  Next 'name
  
  If Not wait_answer Then Return
  'wait for all of the answers
  Repeat
    If (Not got) Then
      Wait 0.01
      timeoutcs -= 0.01
    Endif
    got = True
    For Each name In names
      p = getP(name) 
      If wait_unavailable Then 
        If (p <> Null) And (p <> "(unavailable)") Then names.Remove(names.Find(name))
          Else
        If (p <> Null) Then names.Remove(names.Find(name))
      Endif
      got = (got And (p <> Null))
      If Not got Then 
        global.myDebug("waiting", name)
      Endif
    Next
  Until got Or (Not ProcessRunningOvr()) Or (timeoutcs <= 0)
End



Public Function paused() As Boolean
  Return get_property_mpv("pause") = "yes"
End

' Private Sub mpv_command(command As String[])
'   Dim snip, sbuf As String
' 
'   sbuf = "{ \"command\": ["
'     For Each snip In command
'       sbuf &= "\"" & snip & "\", "
'     Next
'     sbuf = Left(sbuf, -2)
'   sbuf &= "] }" & "\n" '<-serve l'accapo finale? il send già lo manda
' 
'   global.myDebug( sbuf)
'   send(sbuf)
' End

Public Sub mpv_command(command As String[])
  Dim snip, sbuf As String
  For Each snip In command
    sbuf &= "\"" & snip & "\"" 
    sbuf &= " "
  Next
  sbuf = Left(sbuf, -1)
  send(sbuf)
  global.myDebug(sbuf)
End


Public Sub abloop_set_a(Optional timefloat As String = "notset") 'no argument means current time.
  If timefloat = "notset" Then
      set_property_mpv("ab-loop-a", "${=time-pos}")
        Else
      set_property_mpv("ab-loop-a", timefloat)
  Endif
End

Public Sub abloop_set_b(Optional timefloat As String = "notset") 'no argument means current time.
  If timefloat = "notset" Then
      set_property_mpv("ab-loop-b", "${=time-pos}")
        Else
      set_property_mpv("ab-loop-b", timefloat)
  Endif
End

Public Function do_revert_seek(Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "revert_seek"])
      Else
    mpv_command(["no-osd", "revert_seek"])
  Endif
End


Public Function do_seek(Percentual As String, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", Percentual, "absolute-percent"])
      Else
    mpv_command(["no-osd", "seek", Percentual, "absolute-percent"])
  Endif
End
Public Function do_seek_to(newpos As String, Optional precise As Boolean = False, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", newpos, "absolute"]) 'fixmempv precise paramters not implemented 
      Else
    mpv_command(["no-osd", "seek", newpos, "absolute"]) 'fixmempv precise paramters not implemented 
  Endif
End
Public Function do_seek_by(seconds As String, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", seconds, "relative"])
      Else
    mpv_command(["no-osd", "seek", seconds, "relative"])
  Endif
End

Public Sub _new()
  ClearMediaProperties()
End


Public Function send(data As String, Optional osd As Boolean = True)
  If Not ProcessRunningOvr() Then Return
  If osd Then 
    Try Write #mystream, data & "\n"
      Else
    Try Write #mystream, "no-osd " & data & "\n"
  Endif
End


Private Function merge_collections(c1 As Collection, c2 As Collection) As Collection
  'merge c1 with c2
  'c2 overwrites keys of c1
  Dim out As Collection
  For Each c1
    out.Add(c1.key, c1[c1.key])
  Next
  For Each c2
    out.Add(c2.key, c2[c2.key])
  Next  
End


Private Function deQuote(S As String) As String
  If Left(S) = "\"" And Right(S) = "\"" Then
    Return Right(Left(s, -1), -1)
  Endif
  Return s
End



Private Function what_changes(oldc As Collection, newc As Collection) As Collection
  Dim out As New Collection
  Dim data, k As String
  'given 2 collections, returns a new collection
  'built from changed key values, removed keys,added keys
  
  For Each data In newc
    k = Trim(newc.key)
    If oldc.Exist(k) Then
      If deQuote(oldc[k]) <> deQuote(newc[k]) Then 
        global.myDebug("old option changed", k, oldc[k], newc[k])
        out[k] = newc[k]
      Endif
    Endif

  If Not (oldc.Exist(k)) Then
       global.myDebug("New option added", k, newc[k])
       out[k] = newc[k]
    Endif
  Next

  For Each data In oldc
    k = Trim(oldc.key)
    If Not (newc.Exist(k)) Then
       global.myDebug("old option removed", k, oldc[k])
       out[k] = "|(removed)|"
    Endif
  Next

  Return out
  
End



Private ignore_opts As String[]

Public Sub do_apply(new_opts As Collection)
  Dim realtime_opts As String[] = ["af", "af-add", "af-clr", "af-pre", "vf", "vf-add", "vf-clr", "vf-pre"]
  Dim name, data As String
  Dim changed_opts As New Collection
  Dim af_new As String = ""
  Dim vf_new As String = ""
  Dim af_pre_new As String = ""
  Dim vf_pre_new As String = ""
  

  new_opts = fix_options(new_opts)
  'see if we need a restart
  'make a list of changed options
  changed_opts = what_changes(mpvoptions, new_opts)

  For Each changed_opts
    name = changed_opts.Key
    data = changed_opts[changed_opts.Key]
    global.myDebug("changed/added/removed option:", name, data)
    If realtime_opts.Find(name) = -1 Then
      If ignore_opts.find(name) = -1 Then
        global.myDebug("option changed/removed/added: " & name, "requires restart")
        do_apply_restart(new_opts)
        Return
      Endif
    Endif
  Next

'ora abbiamo disponibili la lista di nuove opzioni completa di fixed e realtime
'ma ci servono solo le realtime, quindi dobbiamo selezionarle.
global.myDebug("No changed option requires restart, setting realtime properties instead")
For Each new_opts
  name = new_opts.Key
  data = new_opts[new_opts.Key]
  If realtime_opts.Find(name) >= 0 Then
    Select Case name
      Case "af"
        af_new = data
      Case "af-add"
        If af_new <> "" Then
          af_new = af_new & "," & data
            Else
          af_new = data
        Endif
      Case "af-pre"
        If af_pre_new <> "" Then
          af_pre_new = af_pre_new & "," & data
            Else
          af_pre_new = data
        Endif
      Case "af-clr"
        af_new = ""
        af_pre_new = ""
      Case "vf"
        vf_new = data
      Case "vf-add"
        If vf_new <> "" Then
          vf_new = vf_new & "," & data
            Else
          vf_new = data
        Endif
      Case "vf-pre"
        If vf_pre_new <> "" Then
          vf_pre_new = vf_pre_new & "," & data
            Else
          vf_pre_new = data
        Endif
      Case "vf-clr"
        vf_new = ""
        vf_pre_new = ""
    End Select
  Endif
Next
'Stop
  ' If Left(af_new, "3") = "-1," Then af_new = Right(af_new, -3)
  ' If Left(vf_new, "3") = "-1," Then vf_new = Right(vf_new, -3)

  If Left(af_new) = "," Then af_new = Right(af_new, -1)
  If Left(vf_new) = "," Then vf_new = Right(vf_new, -1)
  If Left(af_pre_new) = "," Then af_new = Right(af_pre_new, -1)
  If Left(vf_pre_new) = "," Then vf_new = Right(vf_pre_new, -1)

  If af_pre_new <> "" Then af_new = af_pre_new & "," & af_new
  If vf_pre_new <> "" Then vf_new = vf_pre_new & "," & vf_new

  If af_new = "|(removed)|" Then af_new = ""
  If vf_new = "|(removed)|" Then vf_new = ""
  

  'If af_new <> "-1" Then 
  'If af_new <> realtime_opts_previous["af"] Then
    set_property_mpv("af", af_new, True)
    'realtime_opts_previous["af"] = af_new
  'Endif
  
  'If vf_new <> "-1" Then 
  'If vf_new <> realtime_opts_previous["vf"] Then 
    set_property_mpv("vf", vf_new, True)
    'realtime_opts_previous["vf"] = vf_new
  'Endif

  ReturnLabel:
  Return

End


Public Sub do_apply_restart(new_opts As Collection)
  Dim name, data, newdata As String
  Dim timepos As String = "0"
  Dim fullpath As String
  Dim restart As Boolean = True
  Dim timerA As Float
  Dim properties_changed_runtime_old_datas As New Collection
  Dim olddata As String = "--------------"
  
  restarting = True
  
  'store old properties so that we can understand if we succeeded in restoring them
  For Each properties_changed_runtime
    name = properties_changed_runtime.key
    data = get_property_mpv(name, True, 100, True)
    properties_changed_runtime_old_datas[name] = data
  Next
  
  
  If ProcessRunningOvr() Then
    clear_options()
    For Each data In new_opts
      set_option(new_opts.key, data)
    Next
    fullpath = getP("fullpath")
    timepos = get_property_mpv("=time-pos")
    set_option("start", timepos)
    do_play(fullpath,, restart = True)
  Endif

  waitplayback(500)

  'Restore properties changed runtime before the restart
  'more tries are needed because mpv needs to initialize
  'before giving any useful answer.
  'so check if the answer is different from "(unavailable")
  'and don't spend too much time anyway waiting for the property.
    For Each properties_changed_runtime
      global.myDebug("Try to restore Property:", name, data)
      timerA = Timer()
      Repeat
        name = properties_changed_runtime.key
        data = properties_changed_runtime[name]
        olddata = Null
        Try olddata = properties_changed_runtime_old_datas[name]
        set_property_mpv(name, data, False)
        Wait 0.01
        newdata = get_property_mpv(name)
      Until (newdata <> "(unavailable)") Or ((Timer() - TimerA) > 10) Or (newdata = olddata) 'dont spend more than one second per property
      'is it possible that newdata is available but still with an unset value, wo, just to be sure, restore it one more time.
      Wait 0.01
      set_property_mpv(name, data, False)
      global.myDebug("Restore property:", name, newdata, data)
    Next

  restarting = False

End


Private man_page As String = ""

Public Function search_man(search_for As String) As String
  'currently only works for drivers and filters
  Dim st, help_str As String
  Dim s_pos As Integer
  If man_page = "" Then
    global.myDebug("Getting mpv man...")
    Shell "man mpv|col -bx" To man_page
  Endif

  For Each st In search_term(search_for)
    s_pos = InStr(man_page, st) 
    If s_pos > 0 Then Return Left(Right(man_page, - s_pos), 80 * 100)
    Wait
  Next
  Return ""
End



Private Sub search_term(item As String) As String[]
  Dim out As New String[]
  Select Case item
    Case "vdpau"
      Return ["   vdpau (X11 only)"]
    Case "vaapi"
      Return ["Intel VA API video"]
  End Select
  out.add("    " & Lower(item) & "[=" & "")
  out.add("    " & Lower(item) & "=[" & "")
  out.add("    " & Lower(item) & "")
  Return out
End

Public Function filters_available(audio As Boolean) As String[]
  Dim f As String
  Dim out, l As String
  Dim filters As New String[]
  If audio Then 
    f = "af"
      Else
    f = "vf"
  Endif
  Shell executable() & " --" & f & "=help" To out
  For Each l In Split(out, "\n", "", True)
    If l Like "* : *" Then
      filters.Add(Trim(Split(l, ":", "", True)[0]))
    Endif
  Next
  Return filters
End



