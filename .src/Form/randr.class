' Gambas class file

Create Static




Public Sub Form_Open()
  buttontimeout.hide
End




Public Struct Xmode
  output_name As String
  mode_name As String
  w As Integer
  h As Integer
  x As Integer
  y As Integer
  r As Float
End Struct

Public Function get_sizes() As String[]
  'given an output name, returns a string[] as follows:
  '[outputname|modename|w|h|refresh],..,[outputname|modename|w|h|refresh]'
  Dim xrandr_output, a, b As String 
  Dim output_name As String
  Dim xrandr_output_splitted As String[]
  Dim tmp As String[]
  Dim i, j, k As Integer
  Dim aLine, bLine As String
  Dim modename, w, h, r As String
  Dim return_value As New String[]
  Dim mode As String
  Dim modes As New String[]
  
  Shell "xrandr --verbose --current" To xrandr_output
  xrandr_output_splitted = Split(xrandr_output, "\n", "", True)
  
  For i = 0 To xrandr_output_splitted.max 'search output_name
    aLine = xrandr_output_splitted[i] 
    If aLine Like "* connected *" Then output_name = Split(aline, " ", "", True)[0]

        If aLine Like "* (*) *Hz*HSync*VSync*" Then 'found the first modeline"
          modename = Split(aLine, " ", "", True)[0]
          a = xrandr_output_splitted[i + 1]
          b = xrandr_output_splitted[i + 2]

          w = Split(a, " ", "", True)[2]
          h = Split(b, " ", "", True)[2]

          tmp = Split(b, " ", "", True)
          r = Replace(tmp[tmp.max], "Hz", "", gb.IgnoreCase)

          mode = output_name & "|" & modename & "|" & w & "|" & h & "|" & r
          modes.Add(mode)
        Endif
  Next 'i
  
  Return modes
  
End


Public Function output_from_screen(s As Screen) As Xmode
  'returns the display output name, resolution and refreshrate of the specified gb screen
  Dim xrandr_output As String
  Dim aLine, element, mode_name As String
  Dim xrandr_output_splitted As String[]
  Dim splitted As String[]
  Dim output_name, w, h, x, y As String
  Dim r As Float = -1
  Dim Xreturn As Xmode
  Dim i, j As Integer

  Shell "xrandr --current" To xrandr_output
  xrandr_output_splitted = Split(xrandr_output, "\n", "", True)
  
  For i = 0 To xrandr_output_splitted.max
    'walk through xrandr lines, search For connected outputs
    aLine = xrandr_output_splitted[i]
    If InStr(aLine, " connected ") > 0 Then
      aLine = Replace(aLine, "primary ", "")
      splitted = Split(aLine, " x+", "", True)
      w = splitted[2]
      h = splitted[3]
      x = splitted[4]
      y = splitted[5]
      If s.w = w Then
        If s.h = h Then
          If s.x = x Then
            If s.y = y Then
              'screen match found
              output_name = splitted[0]
              'extract the refresh. find "*"
              For j = i + 1 To xrandr_output_splitted.max
                aLine = xrandr_output_splitted[j]
                If InStr(aLine, "connected") > 1 Then 
                  Stop
                  Goto returnlabel 'we found the next output definition. No luck.
                Endif
                If InStr(aLine, "*") > 0 Then
                  'found the mode, search which refresh ends with "*"
                  For Each element In Split(aLine, " +", "", True)
                    If Right(element) = "*" Then
                      Try r = CFloat(Left(element, -1))
                      If Not Error Then
                        mode_name = Split(aLine, " ", "", True)[0]
                        Break
                      Endif
                    Endif
                  Next
                Endif
                If r <> -1 Then Break
              Next
              Xreturn = New Xmode
              Xreturn.output_name = output_name
              Xreturn.mode_name = mode_name
              Xreturn.w = w
              Xreturn.h = h
              Xreturn.r = r
              Goto returnlabel
            Endif
          Endif
        Endif
      Endif
    Endif
  Next

  returnlabel:
  Return Xreturn

End


Private Function Screenbypos(x As Integer, y As Integer) As Screen
  Dim s As Screen
  For Each s In Screens
    If (x >= s.x) And x <= (s.x + s.W) Then
      If (y >= s.y) And y <= (s.y + s.h) Then
        Return s
      Endif
    Endif
  Next
  
  'no screen found !? repeat with more tolerance:
  For Each s In Screens
    If (x + 50 >= s.x) And x <= (s.x + s.W + 50) Then
      If (y + 50 >= s.y) And y <= (s.y + s.h + 50) Then
        Return s
      Endif
    Endif
  Next

  'still no screen found? return the first.
  global.myDebug("Couldn 't get the matching screen (!)")
  Return Screens[0]
End

Public Sub Xmode_from_obj(o As Object) As Xmode
  'return on which screen ( output_name) is the center of the object o
  Dim s As Screen
  Dim out As Xmode
  s = Screenbypos(o.screenx + (o.w Div 2), o.screeny + (o.h Div 2))
  Return output_from_screen(s)
End

Public Sub change_mode(output_name As String, mode As String, rate As Float)
  Dim xrandr_cmd As String = "xrandr --output " & output_name & " --mode " & mode & " --rate " & rate
  global.myDebug(xrandr_cmd)
  Shell xrandr_cmd
End


Public Function find_mode(s_output_name As String, s_w As Integer, s_h As Integer, s_fps As Float, Optional AR_ERROR_max As Float = -1, Optional HZ_ERROR_max As Float = -1) As String
  'given an output-name
  'given a source resolution
  'given the source fps
  'Given an output name
  
  'search for a mode that
  '* has the same output name of the source
  '* has the same aspect ratio of the source resolution +/- 5%
  '* has a resolution >= than the source resolution
  '* has a refresh rate multiple of the (requested fps +/- 5%)
  
  'And Return it In this form:  outputname|modename|w|h|refresh|Refresh_error|Aspect_error
  

  Dim modes_db As New String[] ' '[outputname|modename|w|h|refresh],..,[outputname|modename|w|h|refresh]'
  Dim mode As String
  Dim mode_name As String

  Dim output_name As String
  Dim w, h As Integer
  Dim r As Float
  Dim i As Integer

  Dim t As Float
  Dim t_int As Integer
  Dim perfect_refresh As Float
  Dim compensation As Float

  Dim AR_source, AR_dest As Float

  Dim AR_error, Hz_error As Float

  If AR_error_max < 0 Then AR_error = 0.05
  If Hz_error_max < 0 Then Hz_error = 0.05

  modes_db = get_sizes()

  For Each mode In modes_db
    output_name = Split(mode, "|", "", True)[0]
    If output_name = s_output_name Then
      mode_name = Split(mode, "|", "", True)[1] 
      w = CInt(Split(mode, "|", "", True)[2])
      h = CInt(Split(mode, "|", "", True)[3])
      r = CFloat(Split(mode, "|", "", True)[4])

      AR_source = w / h
      AR_dest = s_w / s_h
      AR_ERROR = 1 - Max(Ar_source, Ar_dest) / Min(AR_source, AR_dest)
      If AR_ERROR <= AR_ERROR_max
        global.mydebug("candidate:", mode, "\nHas the same aspect of the source +/- " & AR_ERROR_max)
        'check refresh
        ' come si fa a capire che una frequenza destinazione va bene?
        ' 
        ' divido la frequenza del monitor per quella del filmato, ad esempio
        ' 75 hz / 23.976
        ' esce 3.1281281
        ' poi divido la sua parte decimale per la sua parte intera:
        ' 0.1281281 / 3 = 0.0427
        ' se il numero che esce è inferiore a 0.05 (che rappresenta il mio 5%) allora va bene.

        t = r / s_fps
        t_int = Round(t)
        perfect_refresh = s_fps * t_int
        compensation = r / perfect_refresh
        Hz_error = 1 - compensation 

        If Abs(Hz_error) <= Hz_error_max Then
          global.myDebug("Mode found: " & mode)
          Return mode & "|" & Hz_error & "|" & AR_ERROR
        Endif
        
      Endif
    Endif
  Next
  Stop
  global.myDebug("No mode found")
  Return ""
End

Public Function find_modes(s_output_name As String, s_w As Integer, s_h As Integer, s_fps As Float, Optional AR_ERROR_max As Float = -1, Optional HZ_ERROR_max As Float = -1) As String[]
  'given an output-name
  'given a source resolution
  'given the source fps
  'Given an output name
  
  'search for a mode that
  '* has the same output name of the source
  '* has the same aspect ratio of the source resolution +/- 5%
  '* has a resolution >= than the source resolution
  '* has a refresh rate multiple of the (requested fps +/- 5%)
  
  'And Return it In this form:  outputname|modename|w|h|refresh|Refresh_error|Aspect_error
  
  Dim output_modes As New String[]
  Dim modes_db As New String[] ' '[outputname|modename|w|h|refresh],..,[outputname|modename|w|h|refresh]'
  Dim mode As String
  Dim mode_name As String

  Dim output_name As String
  Dim w, h As Integer
  Dim r As Float
  Dim i As Integer

  Dim t As Float
  Dim t_int As Integer
  Dim perfect_refresh As Float
  Dim compensation As Float

  Dim AR_source, AR_dest As Float

  Dim AR_error, Hz_error As Float


  If AR_error_max < 0 Then AR_error_MAX = 0.05
  If Hz_error_max < 0 Then Hz_error_MAX = 0.05

  modes_db = get_sizes()

  For Each mode In modes_db
    output_name = Split(mode, "|", "", True)[0]
    If output_name = s_output_name Then
      mode_name = Split(mode, "|", "", True)[1] 
      w = CInt(Split(mode, "|", "", True)[2])
      h = CInt(Split(mode, "|", "", True)[3])
      r = CFloat(Split(mode, "|", "", True)[4])

      AR_source = w / h
      AR_dest = s_w / s_h
      AR_ERROR = 1 - Max(Ar_source, Ar_dest) / Min(AR_source, AR_dest)
      If AR_ERROR <= AR_ERROR_max
        global.mydebug("candidate:", mode, "\nHas the same aspect of the source +/- " & AR_ERROR_max)
        If (w >= s_w) And (h >= s_h) Then
          'check refresh
          ' come si fa a capire che una frequenza destinazione va bene?
          ' 
          ' divido la frequenza del monitor per quella del filmato, ad esempio
          ' 75 hz / 23.976
          ' esce 3.1281281
          ' poi divido la sua parte decimale per la sua parte intera:
          ' 0.1281281 / 3 = 0.0427
          ' se il numero che esce è inferiore a 0.05 (che rappresenta il mio 5%) allora va bene.
  
          t = r / s_fps
          t_int = Round(t)
          perfect_refresh = s_fps * t_int
          compensation = r / perfect_refresh
          Hz_error = 1 - compensation 
          If Abs(Hz_error) <= Hz_error_max Then
            global.myDebug("Mode found: " & mode)
            output_modes.Add(mode & "|" & Hz_error & "|" & AR_ERROR)
            'Return mode & "|" & Hz_error & "|" & AR_ERROR
          Endif
        Endif
      Endif
    Endif
  Next
  'Stop
  'global.myDebug("No mode found")
  Return output_modes
End






Private Xmode_stored As Xmode

Public Sub Xmode_from_obj_store(o As Object)
  'will save the mode used by the screen "o" is on
  If Xmode_stored = Null Then 
    Xmode_stored = Xmode_from_obj(o)
  Endif
End
Public Sub Xmode_from_obj_restore()
  'will restore the last saved Xmode
  If Xmode_stored <> Null Then
    change_mode(Xmode_stored.output_name, Xmode_stored.mode_name, Xmode_stored.r)
    Xmode_stored = Null
  Endif
End


Private good_modes As New String[]

Public Sub update(w As Integer, h As Integer, fps As Float)
  Dim Xm As Xmode

  Dim mode As String
  Dim splitmode As String[]
  Dim i As Integer

  Xm = Xmode_from_obj(fmain)

  good_modes = find_modes(Xm.output_name, w, h, fps)
  If good_modes.count = 0 Then Return

  Grid_modes.Rows.count = 0

  Grid_modes.Columns.count = 5
  Grid_modes.Columns[0].Text = ("Output")
  Grid_modes.Columns[1].Text = ("Mode")
  Grid_modes.Columns[2].Text = ("Resolution")
  Grid_modes.Columns[3].Text = ("Rate")
  Grid_modes.Columns[4].Text = ("Rate error")
  'Grid_modes.Columns[5].Text = ("Aspect error")

  'outputname|modename|w|h|refresh|Refresh_error|Aspect_error
  For Each mode In good_modes
    splitmode = Split(mode, "|", "", True)
    Grid_modes.Rows.count += 1
    Grid_modes[Grid_modes.Rows.max, 0].text = splitmode[0]
    Grid_modes[Grid_modes.Rows.max, 1].text = splitmode[1]
    Grid_modes[Grid_modes.Rows.max, 2].text = splitmode[2] & "x" & splitmode[3]
    Grid_modes[Grid_modes.Rows.max, 3].text = splitmode[4]
    Grid_modes[Grid_modes.Rows.max, 4].text = Round(CFloat(splitmode[5] * 100), -2) & "%"
    'Grid_modes[Grid_modes.Rows.max, 5].text = Round(CFloat(splitmode[6] * 100), -2) & "%"
  Next

  For i = 0 To Grid_modes.Columns.max
    Grid_modes.Columns[i].w = -1
  Next
    

End

Public speed_compensation As Float = 1

Public Sub Grid_modes_Activate()
  Dim r As Integer = Grid_modes.row
  Dim output_name As String = Grid_modes[r, 0].text
  Dim mode As String = Grid_modes[r, 1].text
  Dim rate As String = Grid_modes[r, 3].text
  Xmode_from_obj_store(fmain)
  change_mode(output_name, mode, rate)
  speed_compensation = 1 - CFloat(Split(good_modes[r], "|", "", True)[5])
  start_timeout()
End

Public Sub OkBTN_Click()

  Me.close

End


Public Sub start_timeout()
  Dim i As Integer 
  For i = 10 DownTo 0
    Try buttontimeout.visible = True
    If Error Then Return
    buttontimeout.text = ("Keep mode") & " "
    buttontimeout.text &= ("...reverting in") & " "
    buttontimeout.text &= i & " "
    buttontimeout.text &= ("seconds.")
    If Keep_mode = True Then
      Keep_mode = False
      buttontimeout.visible = False
      Return
    Endif
    Wait 1
  Next
  If i <= 0 Then  
    Xmode_from_obj_restore()
    speed_compensation = 1
  Endif
  buttontimeout.visible = False
End

Private keep_mode As Boolean = False
Public Sub ButtonTimeout_Click()
  Keep_mode = True
  buttontimeout.hide
End




Public Sub ApplyBTN_Click()
  fmain.mplayer.set_property_mpv("speed", speed_compensation)
  fmain.mplayer.ShowText("New speed: " & speed_compensation)
End
